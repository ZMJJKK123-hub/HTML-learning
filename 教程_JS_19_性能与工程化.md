# JavaScript 第 19 步：性能与工程化

配套演示：HTMLlearning/19_js_perf_engineering.html

## 目标
- 理解前端性能关注点：首屏体积、执行/渲染开销、网络与缓存。
- 了解代码分割与动态导入的意义，按需加载重模块。
- 会用 requestIdleCallback（或回退）在空闲时批处理任务。
- 知道缓存与版本号的作用（本地存储示例），避免旧资源干扰。
- 认识工程化方向：构建、Tree Shaking、代码分割、Lint/Format、TS 入门（概念级）。

---

## 1. 代码分割与动态导入
- 按需加载：`import('./path/module.js')`，可减少首屏包体。
- 适用场景：重型算法、管理后台的次级页、低频功能。
- 注意：动态导入返回 Promise，需要 async/await。

## 2. 空闲调度（requestIdleCallback 回退）
- 高频/大批量任务可分批在空闲时处理，避免长任务阻塞。
- 兼容：无 rIC 时可退化为 setTimeout。

## 3. 缓存与版本
- 浏览器缓存可能留存旧资源；用版本号（如 `?v=1.0.0`）或文件指纹（构建产物）控制更新。
- 示例用 localStorage 模拟“命中/写入”缓存。

## 4. 工程化要点（概念）
- 构建与包管理：使用 Vite/Webpack/Rollup + npm/pnpm。
- Tree Shaking：确保使用 ES Module，移除未引用代码。
- 代码分割：按路由或功能拆分 chunk。
- Lint/Format：ESLint + Prettier 统一风格与质量。
- TypeScript：逐步在新文件启用 TS，提高类型安全。

---

## 实践任务
1) 将 heavy-math 拆分为更多函数，演示“仅导入用到的导出”并观察体积（概念）。
2) 在空闲调度中把 2000 提升到 10000，观察 UI 是否卡顿；必要时缩小 batch。
3) 为缓存示例加入“版本不一致时清理旧缓存”的逻辑。
4) 了解并记录：如果使用 Vite，如何配置 chunk 分割与 hash 输出（写在注释里）。

---

## 小提示
- 避免长任务：拆分成小块，或交给 rIC/队列。
- 资源命名要有版本/哈希，结合缓存策略（Cache-Control/ETag）。
- 使用浏览器性能面板查看长任务、脚本体积、网络瀑布。
